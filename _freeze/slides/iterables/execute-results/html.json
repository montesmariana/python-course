{
  "hash": "da4a02361327d9a2a1f2459df87e7dce",
  "result": {
    "markdown": "---\ntitle: \"Working with iterables\"\nformat: revealjs\n---\n\n## Lists\n\n**Problem**: I have a text and I would like to know:\n\n- How many types and tokens it has\n\n- How long its words are\n\n. . .\n\n**How do we go about this with Python?**\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ntext = (\"This is a text with a few words and \"\n    \"no punctuation and it is easy to work with\")\ntext\n```\n\n::: {.cell-output .cell-output-display execution_count=438}\n```\n'This is a text with a few words and no punctuation and it is easy to work with'\n```\n:::\n:::\n\n\n## Basic tokenization\n\nWe'll turn the text into all lower case and make a list splitting it via the spaces.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ntokenized_text = text.lower().split(' ')\ntokenized_text\n```\n\n::: {.cell-output .cell-output-display execution_count=439}\n```\n['this',\n 'is',\n 'a',\n 'text',\n 'with',\n 'a',\n 'few',\n 'words',\n 'and',\n 'no',\n 'punctuation',\n 'and',\n 'it',\n 'is',\n 'easy',\n 'to',\n 'work',\n 'with']\n```\n:::\n:::\n\n\n## Types and tokens\n\nTokens are the individual elements.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nn_tokens = len(tokenized_text)\nf\"My text has {n_tokens} tokens.\"\n```\n\n::: {.cell-output .cell-output-display execution_count=440}\n```\n'My text has 18 tokens.'\n```\n:::\n:::\n\n\n. . .\n\nTypes are _unique_ elements.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ntypes = set(tokenized_text)\ntypes\n```\n\n::: {.cell-output .cell-output-display execution_count=441}\n```\n{'a',\n 'and',\n 'easy',\n 'few',\n 'is',\n 'it',\n 'no',\n 'punctuation',\n 'text',\n 'this',\n 'to',\n 'with',\n 'words',\n 'work'}\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nn_types = len(types)\n```\n:::\n\n\n## Info summary\n\n::: {.cell execution_count=6}\n``` {.python .cell-code .code-overflow-wrap}\n(f\"My text has {n_tokens} tokens and {n_types} types, \"\nf\"i.e. a type token ratio of {round(n_tokens/n_types, 2)}.\")\n```\n\n::: {.cell-output .cell-output-display execution_count=443}\n```\n'My text has 18 tokens and 14 types, i.e. a type token ratio of 1.29.'\n```\n:::\n:::\n\n\n. . .\n\nOK, what about the length of *each* word?\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nwords = list(types)\nprint(words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['a', 'few', 'words', 'with', 'it', 'to', 'easy', 'work', 'punctuation', 'is', 'text', 'no', 'and', 'this']\n```\n:::\n:::\n\n\n## for loops\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfor word in words:\n    print(word)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\nfew\nwords\nwith\nit\nto\neasy\nwork\npunctuation\nis\ntext\nno\nand\nthis\n```\n:::\n:::\n\n\n::: {.footer}\n[More about `for` loops](https://docs.python.org/3.10/tutorial/controlflow.html#for-statements)\n:::\n\n## for loops\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nfor word in words:\n    print(f'\"{word}\" is {len(word)} characters long.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\"a\" is 1 characters long.\n\"few\" is 3 characters long.\n\"words\" is 5 characters long.\n\"with\" is 4 characters long.\n\"it\" is 2 characters long.\n\"to\" is 2 characters long.\n\"easy\" is 4 characters long.\n\"work\" is 4 characters long.\n\"punctuation\" is 11 characters long.\n\"is\" is 2 characters long.\n\"text\" is 4 characters long.\n\"no\" is 2 characters long.\n\"and\" is 3 characters long.\n\"this\" is 4 characters long.\n```\n:::\n:::\n\n\n::: {.footer}\n[More about `for` loops](https://docs.python.org/3.10/tutorial/controlflow.html#for-statements)\n:::\n\n## New list with a for loop\n\nWe could start an empty list and then, with a `for` loop, go through each token, count its characters and add it to the list.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nword_lengths = []\nfor word in words:\n    word_lengths.append(len(word))\nprint(word_lengths)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 3, 5, 4, 2, 2, 4, 4, 11, 2, 4, 2, 3, 4]\n```\n:::\n:::\n\n\n::: callout-important\n### Note\nThis is not the recommended way to create a new list!\n:::\n\n## List of word lengths\n\nThen we can do different things:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nf\"The shortest word in my text has {min(word_lengths)} character.\"\n```\n\n::: {.cell-output .cell-output-display execution_count=448}\n```\n'The shortest word in my text has 1 character.'\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nf\"The longest word in my text has {max(word_lengths)} characters.\"\n```\n\n::: {.cell-output .cell-output-display execution_count=449}\n```\n'The longest word in my text has 11 characters.'\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nf\"The average word length in my text is {round(sum(word_lengths)/len(word_lengths), 2)} characters.\"\n```\n\n::: {.cell-output .cell-output-display execution_count=450}\n```\n'The average word length in my text is 3.64 characters.'\n```\n:::\n:::\n\n\n## Combining two lists\n\nWe can combine two lists of equal length with `zip()`.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nfor item in zip(words, word_lengths):\n    print(item)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n('a', 1)\n('few', 3)\n('words', 5)\n('with', 4)\n('it', 2)\n('to', 2)\n('easy', 4)\n('work', 4)\n('punctuation', 11)\n('is', 2)\n('text', 4)\n('no', 2)\n('and', 3)\n('this', 4)\n```\n:::\n:::\n\n\n## for loop on combined lists\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nfor word, length in zip(words, word_lengths):\n    print(f'The word \"{word}\" has {length} characters.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe word \"a\" has 1 characters.\nThe word \"few\" has 3 characters.\nThe word \"words\" has 5 characters.\nThe word \"with\" has 4 characters.\nThe word \"it\" has 2 characters.\nThe word \"to\" has 2 characters.\nThe word \"easy\" has 4 characters.\nThe word \"work\" has 4 characters.\nThe word \"punctuation\" has 11 characters.\nThe word \"is\" has 2 characters.\nThe word \"text\" has 4 characters.\nThe word \"no\" has 2 characters.\nThe word \"and\" has 3 characters.\nThe word \"this\" has 4 characters.\n```\n:::\n:::\n\n\n## Generators\n\n`zip()` doesn't return a list but a *generator*:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nzip(words, word_lengths)\n```\n\n::: {.cell-output .cell-output-display execution_count=453}\n```\n<zip at 0x7fcf24155340>\n```\n:::\n:::\n\n\nOther useful generators are `range()` and `enumerate()`:\n\n:::: {.columns}\n::: {.column width=\"40%\"}\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nrange(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=454}\n```\nrange(0, 3)\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nfor i in range(3):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n```\n:::\n:::\n\n\n:::\n::: {.column width=\"60%\"}\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nenumerate(['a', 'b', 'c'])\n```\n\n::: {.cell-output .cell-output-display execution_count=456}\n```\n<enumerate at 0x7fcf24154300>\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nfor item in enumerate(['a', 'b', 'c']):\n    print(item)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0, 'a')\n(1, 'b')\n(2, 'c')\n```\n:::\n:::\n\n\n:::\n::::\n\n## Other generators: `range()`\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nfor i in range(len(words)):\n    print(f'\"{words[i]}\" is token N.{i} in my text'\n    f'and has {word_lengths[i]} characters.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\"a\" is token N.0 in my textand has 1 characters.\n\"few\" is token N.1 in my textand has 3 characters.\n\"words\" is token N.2 in my textand has 5 characters.\n\"with\" is token N.3 in my textand has 4 characters.\n\"it\" is token N.4 in my textand has 2 characters.\n\"to\" is token N.5 in my textand has 2 characters.\n\"easy\" is token N.6 in my textand has 4 characters.\n\"work\" is token N.7 in my textand has 4 characters.\n\"punctuation\" is token N.8 in my textand has 11 characters.\n\"is\" is token N.9 in my textand has 2 characters.\n\"text\" is token N.10 in my textand has 4 characters.\n\"no\" is token N.11 in my textand has 2 characters.\n\"and\" is token N.12 in my textand has 3 characters.\n\"this\" is token N.13 in my textand has 4 characters.\n```\n:::\n:::\n\n\n## Other generators: `enumerate()`\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nfor i, word in enumerate(words):\n    print(f'\"{word}\" is token N.{i} in my text and has {word_lengths[i]} characters.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\"a\" is token N.0 in my text and has 1 characters.\n\"few\" is token N.1 in my text and has 3 characters.\n\"words\" is token N.2 in my text and has 5 characters.\n\"with\" is token N.3 in my text and has 4 characters.\n\"it\" is token N.4 in my text and has 2 characters.\n\"to\" is token N.5 in my text and has 2 characters.\n\"easy\" is token N.6 in my text and has 4 characters.\n\"work\" is token N.7 in my text and has 4 characters.\n\"punctuation\" is token N.8 in my text and has 11 characters.\n\"is\" is token N.9 in my text and has 2 characters.\n\"text\" is token N.10 in my text and has 4 characters.\n\"no\" is token N.11 in my text and has 2 characters.\n\"and\" is token N.12 in my text and has 3 characters.\n\"this\" is token N.13 in my text and has 4 characters.\n```\n:::\n:::\n\n\n## Comprehension lists\n\nThe problem of creating a list (like `word_lengths`) with a for loop is that the computer doesn't know how long it is going to be. A more direct way is to use **comprehension lists**.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nword_lengths = [len(word) for word in words]\nprint(word_lengths)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 3, 5, 4, 2, 2, 4, 4, 11, 2, 4, 2, 3, 4]\n```\n:::\n:::\n\n\n::: callout-warning\nIt's better to create new lists with comprehension lists,\nbut if what you want to do is *print some output*, then use a `for` loop (so you don't create anything new).\n:::\n\n## Also for dictionaries!\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nword_lengths_dict = { w : len(w) for w in words}\nword_lengths_dict\n```\n\n::: {.cell-output .cell-output-display execution_count=461}\n```\n{'a': 1,\n 'few': 3,\n 'words': 5,\n 'with': 4,\n 'it': 2,\n 'to': 2,\n 'easy': 4,\n 'work': 4,\n 'punctuation': 11,\n 'is': 2,\n 'text': 4,\n 'no': 2,\n 'and': 3,\n 'this': 4}\n```\n:::\n:::\n\n\n## Use a dictionary in a loop\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nfor key in word_lengths_dict:\n    print(f'The word \"{key}\" has {word_lengths_dict[key]} characters.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe word \"a\" has 1 characters.\nThe word \"few\" has 3 characters.\nThe word \"words\" has 5 characters.\nThe word \"with\" has 4 characters.\nThe word \"it\" has 2 characters.\nThe word \"to\" has 2 characters.\nThe word \"easy\" has 4 characters.\nThe word \"work\" has 4 characters.\nThe word \"punctuation\" has 11 characters.\nThe word \"is\" has 2 characters.\nThe word \"text\" has 4 characters.\nThe word \"no\" has 2 characters.\nThe word \"and\" has 3 characters.\nThe word \"this\" has 4 characters.\n```\n:::\n:::\n\n\n## Like `enumerate()`\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nfor key, value in word_lengths_dict.items():\n    print(f'The word \"{key}\" has {value} characters.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe word \"a\" has 1 characters.\nThe word \"few\" has 3 characters.\nThe word \"words\" has 5 characters.\nThe word \"with\" has 4 characters.\nThe word \"it\" has 2 characters.\nThe word \"to\" has 2 characters.\nThe word \"easy\" has 4 characters.\nThe word \"work\" has 4 characters.\nThe word \"punctuation\" has 11 characters.\nThe word \"is\" has 2 characters.\nThe word \"text\" has 4 characters.\nThe word \"no\" has 2 characters.\nThe word \"and\" has 3 characters.\nThe word \"this\" has 4 characters.\n```\n:::\n:::\n\n\n## List of dictionaries\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ndiscworld_death = [\n    { 'title' : 'Mort', 'year' : 1987},\n    { 'title' : 'Reaper Man', 'year' : 1991},\n    { 'title' : 'Soul Music', 'year' : 1994},\n    { 'title' : 'Hogfather', 'year' : 1996},\n    { 'title' : 'Thief of time', 'year' : 2001}\n]\n```\n:::\n\n\n. . .\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nfor i, book in enumerate(discworld_death):\n    print(f'Book N.{i+1} of the Death series is \"{book[\"title\"]}\", published in {book[\"year\"]}.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBook N.1 of the Death series is \"Mort\", published in 1987.\nBook N.2 of the Death series is \"Reaper Man\", published in 1991.\nBook N.3 of the Death series is \"Soul Music\", published in 1994.\nBook N.4 of the Death series is \"Hogfather\", published in 1996.\nBook N.5 of the Death series is \"Thief of time\", published in 2001.\n```\n:::\n:::\n\n\n# While\n\n## while\n\nIn a `for` loop, you have a list or generator and you go through its items one by one.\n\nWith `while`, you create a loop that depends on a condition.\n\n::: {.cell output-location='slide' execution_count=29}\n``` {.python .cell-code}\nimport random\nimport time\nrandom.seed(7)\ni = 0\nwhile i < 80:\n    print(\"i is too small yet.\")\n    time.sleep(1)\n    i = random.randint(1, 100)\n    print(f\"i is now {i}.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ni is too small yet.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\ni is now 42.\ni is too small yet.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\ni is now 20.\ni is too small yet.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\ni is now 51.\ni is too small yet.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\ni is now 84.\n```\n:::\n:::\n\n\n# Next up: conditions\n\n",
    "supporting": [
      "iterables_files"
    ],
    "filters": [],
    "includes": {}
  }
}